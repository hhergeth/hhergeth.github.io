<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
        <title>Map</title>
        <script src="libs/moment.min.js" type="text/javascript"></script>
        <script src="libs/lightpick.js" type="text/javascript"></script>
        <script src="libs/leaflet/leaflet.js" type="text/javascript"></script>
        <script src="libs/leaflet.polylineDecorator.js" type="text/javascript"></script>
        <script src="libs/Leaflet-MiniMap/Control.MiniMap.min.js" type="text/javascript"></script>
        <script src="libs/leaflet-measure-path.js" type="text/javascript"></script>
        <script src="libs/leaflet.contextmenu.min.js" type="text/javascript"></script>
        <script src="libs/leaflet-sidebar.min.js" type="text/javascript"></script>
        <script src="libs/spin.js" type="text/javascript"></script>
        <script src="libs/leaflet.spin.js" type="text/javascript"></script>
        <script src="libs/leaflet-ruler.js" type="text/javascript"></script>
        <script src="libs/proj4.js" type="text/javascript"></script>
        <script src="libs/Leaflet.MetricGrid.js" type="text/javascript"></script>
        <script src="libs/leaflet-shades.js" type="text/javascript"></script>
        <script src="frontline.module.js" type="text/javascript" charset="UTF-8"></script>
        <script src="persons.module.js" type="text/javascript" charset="UTF-8"></script>
        <script src="location.module.js" type="text/javascript" charset="UTF-8"></script>
        <script src="utils.js" type="text/javascript" charset="UTF-8"></script>
        <link href="libs/leaflet/leaflet.css" rel="stylesheet">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
        <link href="libs/lightpick.css" rel="stylesheet">
        <link href="libs/Leaflet-MiniMap/Control.MiniMap.min.css" rel="stylesheet">
        <link href="libs/leaflet-measure-path.css" rel="stylesheet">
        <link href="libs/leaflet.contextmenu.min.css" rel="stylesheet">
        <link href="libs/spin.css" rel="stylesheet">
        <link href="libs/leaflet-ruler.css" rel="stylesheet">
        <link href="libs/leaflet-sidebar.min.css" rel="stylesheet">
        <link href="libs/leaflet-shades.css" rel="stylesheet">
        <style>
            body {
                padding: 0;
                margin: 0;
            }

            html,
            body,
            #map {
                height: 100%;
                width: 100%;
            }

            .legend {
                line-height: 18px;
                color: #555;
            }

            .legend i {
                width: 35px;
                height: 6px;
                float: left;
                margin-top: 6px;
                margin-right: 8px;
                opacity: 1.0;
            }
            
            .timebutton {
                font-size:15px;
            }

            .frontline-label {
                position: absolute;
                font-size:14px;
                font-weight: 600;
                color:red;
                background: transparent;
                border: none;
                box-shadow: none;
            }

            .maptile-label-processed {
                color:black;
            }
            .maptile-label-unavailable {
                color:gray;
            }
            .maptile-label-available {
                color:red;
            }
            .maptile-label-processed, .maptile-label-unavailable, .maptile-label-available {
                position: absolute;
                font-size:17px;
                font-weight: 600;
                background: transparent;
                border: none;
                box-shadow: none;
            }
        </style>
    </head>
    <body>
        <div id="map" data-tap-disabled="true"></div>

        <div id="date-element">
            <button class="timebutton" onclick="btn_change_date(event, 0, -1, 'days')">&lt;</button>
            <button class="timebutton" onclick="btn_change_date(event, 0, -1, 'months')">&lt;&lt;</button>
            <input class="date-picker" id="pick1">
            <button class="timebutton" onclick="btn_change_date(event, 0, +1, 'months')">>></button>
            <button class="timebutton" onclick="btn_change_date(event, 0, +1, 'days')">></button>
            <button class="timebutton" onclick="btn_right()" id="btn_right"><i class="fa fa-arrow-right"></i></button>
            <button class="timebutton" onclick="btn_link(this)" id="btn_link"><i class="fa fa-link"></i></button>
            <button class="timebutton" onclick="btn_left()" id="btn_left"><i class="fa fa-arrow-left"></i></button>
            <button class="timebutton" onclick="btn_change_date(event, 1, -1, 'days')">&lt;</button>
            <button class="timebutton" onclick="btn_change_date(event, 1, -1, 'months')">&lt;&lt;</button>
            <input class="date-picker" id="pick2">
            <button class="timebutton" onclick="btn_change_date(event, 1, +1, 'months')">>></button>
            <button class="timebutton" onclick="btn_change_date(event, 1, +1, 'days')">></button>
        </div>

        <div id="search-content">
            <p>This tool lets you search for location names in the old 1:300000 historic maps.</p>

            <p>You can select an area on the map to which you narrow down the search.</p>
            <button class="btn" onclick="startSelectArea()" style="display: block; margin: 0 auto;">Select Area</button>

            <p>Now enter a location name:</p>
            <input type="text" id="loc-name" style="display: block; margin: 0 auto;">

            <p>The name will be compared to all location names in the database using the <a href="https://en.wikipedia.org/wiki/Edit_distance">Edit Distance</a>. If the edit distance between the two is small than a certain threshhold it will be included in the results.<br><br> Maximum edit distance:</p>
            <input type="text" id="max-distance" style="display: block; margin: 0 auto;" value="4">

            <br>

            <button class="btn" onclick="searchLocations()" style="display: block; margin: 0 auto;">Search</button>

            <br>

            <ul id="search-results"></ul>

            <br>

            <button class="btn" onclick="hideSelectedArea()" style="display: block; margin: 0 auto;">Delete</button>
        </div>

        <div id="sidebar" class="leaflet-sidebar collapsed">
            <!-- nav tabs -->
            <div class="leaflet-sidebar-tabs">
                <!-- top aligned tabs -->
                <ul role="tablist">
                    <li><a href="#home" role="tab"><i class="fa fa-bars active"></i></a></li>
                    <li><a href="#text-search" role="tab"><i class="fa fa-search"></i></a></li>
                    <li><a href="#historic-map" role="tab"><i class="fa fa-map"></i></a></li>
                </ul>
            </div>

            <!-- panel content -->
            <div class="leaflet-sidebar-content">
                <div class="leaflet-sidebar-pane" id="home">
                    <h1 class="leaflet-sidebar-header">
                        Interactive World War 2 Map
                        <span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span>
                    </h1>

                    <p>description.</p>
                </div>

                <div class="leaflet-sidebar-pane" id="text-search">
                    <h1 class="leaflet-sidebar-header">
                        Text Search
                        <span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span>
                    </h1>

                    <div id="search-element">
                        <p>Please wait while the necessary data is loading</p>

                        <br>

                        <div id="search-element-spinner">
                            <div id="loadingcont">
                                <p id="loadingspinr">
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="leaflet-sidebar-pane" id="historic-map">
                    <h1 class="leaflet-sidebar-header">
                        Historic Maps
                        <span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span>
                    </h1>

                    <p>Enter the url for the historic maps below:</p>

                    <input type="text" id="historic-map-url-input" style="display: block; margin: 0 auto;" value="">

                    <br>

                    <button class="btn" onclick="loadHistoricMaps()" style="display: block; margin: 0 auto;">Load</button>
                </div>
            </div>
        </div>

        <script>
            var base_year = 1939;
            var year_colors = ['#ffe119', '#3cb44b', '#e6194B', '#4363d8', '#f58231', '#469990', '#f032e6', '#fabebe'];
            var person_colors = ["green", "blue", "violet", "orange", "black"];
            var historic_map_key = "historic-map-url";

            var picker = null;
            var map = null;
            var base_layers = {};
            var optional_layers = {};

            var person_groups = [];
            var historic_map_group = null;
            var frontline_group = null;
            var frontline_label_group = null;
            var circle_group = null;
            var person_control = null;
            var rect = null;
            var shades = null;

            var person_data = {};
            var frontline_data = [];
            var location_data = null;

            function getPersonColor(idx) {
                return person_colors[idx % person_colors.length];
            }
            
            function getYearColor(year) {
                year = Math.min(year, base_year + year_colors.length - 1);
                return year_colors[year - base_year];
            }
            
            function get_dash(annotations) {
                var dashes = null;
                if(annotations.includes("k"))
                    dashes = "1, 0";
                if(annotations.includes("v"))
                    dashes = "4, 24";
                if(annotations.includes("f"))
                    dashes = "5, 5";
                if(annotations.includes("u"))
                    dashes = "40, 10";
                if(annotations.includes("t"))
                    dashes = "20, 30";
                return dashes;
            }
            
            function add_transition(latlng1, latlng2, date1, date2, colorf, annotations, group) {
                var opacity_line = 1.0;
                if(annotations.includes("?") || annotations.includes("o") || annotations.includes("z"))
                    opacity_line = 0.65;
            
                var dashes = get_dash(annotations);
                    
                var line = L.polyline([latlng1, latlng2], {
                    color: colorf,
                    opacity: opacity_line,
                    dashArray: dashes,
                    showMeasurements: true,
                }).addTo(group);
            
                line.formatDistance = function(d) {
                    var unit, distance_text;
                    if (d > 1000) {
                        d = d / 1000;
                        unit = 'km';
                    } else {
                        unit = 'm';
                    }
            
                    if (d < 100) {
                        distance_text = d.toFixed(1) + ' ' + unit;
                    } else {
                        distance_text = Math.round(d) + ' ' + unit;
                    }
                    
                    var f = 'D.MMM';
                    return moment(date1).format(f) + " - " + distance_text + " - " + moment(date2).format(f);
                }
                
                var arrowHead = L.polylineDecorator(line, {
                    patterns: [
                        {
                            offset: '100%',
                            repeat: 0,
                            symbol: L.Symbol.arrowHead({pixelSize: 18, polygon: false, pathOptions:{
                                stroke: true,
                                color: colorf,
                                opacity: opacity_line,
                            }})
                        }
                    ]
                }).addTo(group);
            }
            
            function plot(date_start, date_end) {    
                var person_idx = 0;
                for (var person_name in person_data) {
                    var places = person_data[person_name].places;
                    var route = person_data[person_name].route;
                    
                    var transitions_group = new L.featureGroup();
                    var places_group = new L.featureGroup();
                    
                    var used_places = new Set();
                    
                    for (var idx = 0; idx < route.length - 1; idx++) {
                        var place1 = route[idx + 0].place;
                        var place2 = route[idx + 1].place;
                        var date1 = new moment(route[idx + 0].date, 'DD.MM.YYYY');
                        var date2 = new moment(route[idx + 1].date, 'DD.MM.YYYY');
                        
                        if(new moment(date_end).isSameOrAfter(date1, 'day') && date2.isSameOrAfter(new moment(date_start), 'day')) {
                            var color = getYearColor(new Date(date1).getFullYear());
                            var coords1 = places[place1].coordinates;
                            var coords2 = places[place2].coordinates;
                            var annotations = "k";
                            if("annotations" in route[idx + 1])
                                annotations = route[idx + 1].annotations
                            add_transition(coords1, coords2, date1, date2, color, annotations, transitions_group);
                            
                            used_places.add(place1);
                            used_places.add(place2);
                        }
                    }
                    
                    var person_icon = new L.Icon({
                        iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-' + getPersonColor(person_idx) + '.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    });
                    
                    for (let  place_name of used_places) {
                        var latlng = places[place_name].coordinates;
                        if(latlng.length != 2)
                            console.log(place_name)
                        if(latlng != null) {
                            var marker = L.marker(latlng, {
                                title: place_name,
                                icon: person_icon
                            }).addTo(places_group).bindPopup(place_name);
                        }
                    }
                    
                    person_group = person_groups[person_name];
                    person_group.clearLayers();
                    places_group.addTo(person_group);
                    transitions_group.addTo(person_group);
                    
                    person_idx = person_idx + 1;
                }
                
                frontline_group.clearLayers();
                frontline_label_group.clearLayers();
                frontline_group.addLayer(frontline_label_group);

                //iterate over all fronts and for each find the closest match
                var front_names = ['West', 'East', 'North', 'South', 'Africa'];
                for(let front_name of front_names) {
                    let tagged_charts_start = frontline_data.reduce((total, v) => closest_front(total, v, date_start, front_name, 'before'), null);
                    let tagged_charts_end = frontline_data.reduce((total, v) => closest_front(total, v, date_end, front_name, 'before'), null);
                    
                    //they can be the same ones => don' draw them twice
                    var sq = [];
                    if(tagged_charts_start != null)
                        sq.push(tagged_charts_start);
                    if(tagged_charts_end != null && (sq.length == 0 || sq[0].date != tagged_charts_end.date))
                        sq.push(tagged_charts_end);

                    //the total area of all charts for this front
                    var total_area = 0;
                    var sum_centroids_x = 0;
                    var sum_centroids_y = 0;
                    var num_centroid = 0;
                    for (let tagged_charts of sq) {
                        for(let chart of tagged_charts.charts) {
                            if(chart.outer.length == 0)
                                continue;

                            var polygon = L.polygon([chart.outer].concat(chart.inner), {color: 'red', opacity: 0.25}).addTo(frontline_group);
                            total_area += polygonArea(chart.outer);
                            var center = getCentroid2(chart.outer);
                            sum_centroids_x += center[0];
                            sum_centroids_y += center[1];
                            num_centroid++;
                        }
                    }

                    if(total_area > 5) {
                        var center = [sum_centroids_x / num_centroid, sum_centroids_y / num_centroid];
                        var myTextLabel = L.marker(center, {
                            icon: L.divIcon({
                                className: 'frontline-label',
                                html: moment(sq[0].date).format('DD.MM.YYYY') + "\n" + front_name
                            }),
                            draggable: false
                        }).addTo(frontline_label_group);
                    }
                }
            }

            function selectPersons(persons, start_date, end_date) {
                person_groups = [];
                for (var person_name in person_data) {
                    var person_group = L.layerGroup();
                    person_group.addTo(map);
                    person_groups[person_name] = person_group;
                }
                
                plot(start_date, end_date);

                person_groups_html = [];
                var idx = 0;
                for(var entry_name in person_groups) {
                    var html_name = '<span style="color:' + getPersonColor(idx) + '">' + entry_name + '</span>';
                    person_groups_html[html_name] = person_groups[entry_name];
                    idx = idx + 1;
                }

                if(person_control != null)
                    person_control.remove();
                person_control = L.control.layers(null, person_groups_html,{collapsed:false, position: 'bottomleft'}).addTo(map);
            }

            function initializeHistoricMap(historic_map_url) {
                if(historic_map_group != null) {
                    console.log("Cannot reset the historic mal url to: " + historic_map_url);
                    return
                }

                historic_map_group = new L.featureGroup();
                base_layers["Übersichtskarten 1:300.000"] = historic_map_group;
    
                var historicTiles = L.tileLayer(historic_map_url + '/{z}/{x}/{y}.png', {
                    minZoom: 0, maxZoom: 14,
                    maxNativeZoom: 12
                }).addTo(historic_map_group);

                var myCustomStyle = {
                    stroke: true,
                    fill: false,
                    color: "black",
                    width: 1.5,
                    opacity: 0.5
                }
                load_json('data/country-borders-geo.json').then(country_borders_geo => {
                    L.geoJson(country_borders_geo, {
                        clickable: false,
                        style: myCustomStyle
                    }).addTo(historic_map_group);
                });

                var historic_map_tile_label_group = new L.featureGroup();

                load_json('data/historic_maps_info.json').then(historic_maps_info => {
                    load_json(historic_map_url + '/historic_map_annotations.json').then(historic_maps_processed => {
                        for (let map_info of historic_maps_info) {
                            var loc_center = [map_info[1] - 0.5, map_info[2] + 1];
                            cName = "unavailable";
                            var is_processed = historic_maps_processed.indexOf(map_info[0]) >= 0;
                            var is_available = map_info[5];
                            if(is_processed)
                                cName = 'processed';
                            if(!is_processed && is_available)
                                cName = 'available';
                    
                            var myTextLabel = L.marker(loc_center, {
                                icon: L.divIcon({
                                    className: 'maptile-label-'+cName,
                                    html: map_info[3]
                                }),
                                draggable: false,
                                zIndexOffset: 1000
                            }).addTo(historic_map_tile_label_group);
                            if(map_info[4] != "")
                                myTextLabel.bindTooltip(map_info[4]);
                        }
                    });
                });

                var historic_map_tiles_name = "Übersichtskarten Names";
                optional_layers[historic_map_tiles_name] = historic_map_tile_label_group;

                var historic_tile_labels_shown = false;
                var ignore_map_remove = false;
                map.on({
                    overlayadd: function(e1) {
                        if (e1.name === historic_map_tiles_name){
                            historic_tile_labels_shown = true;
                        }
                    },
                    overlayremove: function(e) {
                        if (e.name === historic_map_tiles_name && !ignore_map_remove) {
                            historic_tile_labels_shown = false;
                        }
                    }
                });

                //hide the map names on the large zooms
                function toggleZoomHistoric(initial) {
                    if(!initial && historic_tile_labels_shown) {
                        if (map.getZoom() < 5){
                            ignore_map_remove = true;
                            map.removeLayer(historic_map_tile_label_group);
                            ignore_map_remove = false;
                        }
                        else map.addLayer(historic_map_tile_label_group);
                    }
                }

                map.on('zoomend', () => toggleZoomHistoric(false));
                toggleZoomHistoric(true);
            }

            //the DHG = Deutsche Heeres Gitter is very similar to UTM but only differes in scale factor and ellipsoid
            //I am still using the WGS84 datum here instead of Potsdam because I loaded the maps incorrectly            
            //https://global-geography.org/attach/Geography/Cross-country_information/Buchroithner.pdf
            //http://www.gpsforum.geospector.de/phpbb/viewtopic.php?f=6&t=1513
            //http://osgeo-org.1560.x6.nabble.com/System-42-83-S42-83-td3850558.html
            function createDHG(layer) {
                L.DHG = L.MetricGrid.extend({
                    options: {
                        bounds: [[100000, 0] , [900000, 9400000]],
                        maxInterval: 1000000
                    },

                    initialize: function(zone, options) {
                        var lon = ((6 * Math.abs(zone)) - 183);
                        options.proj4ProjDef= "+proj=tmerc +lat_0=0 +lon_0=" + lon +  " +k_0=1 +x_0=500000 +y_0=0 +ellps=bessel +datum=WGS84 +units=m +no_defs";
                        options.latLonClipBounds = [[40, -180 + ((zone - 1) * 6)], [80, -180 + ((zone - 1) * 6) + 6]];
                        L.setOptions(this, options);
                    }
                });

                for(var zone_idx = 30; zone_idx < 42; zone_idx++) {
                    var zone_grid = new L.DHG(zone_idx, {color:'red'});
                    layer.addLayer(zone_grid);
                }
            }
                
            window.onload=function(){
                var osm_layer = L.tileLayer('https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', {
                    maxZoom: 18,
                });
                base_layers["OSM"] = osm_layer;
            
                map = L.map('map', {
                    editable: true,
                    zoomControl: false,
                    attributionControl: false,
                    contextmenu: true,
                    contextmenuItems: [{
                        text: 'Show coordinates',
                        callback: showCoordinates
                    }, {
                        text: 'Create Circle',
                        callback: addCircle
                    }, {
                        text: 'Remove All Circles',
                        callback: removeCircles
                    }]
                }).addLayer(osm_layer);

                var sidebar = L.control.sidebar({
                    autopan: false,       // whether to maintain the centered map point when opening the sidebar
                    closeButton: true,    // whether t add a close button to the panes
                    container: 'sidebar', // the DOM container or #ID of a predefined sidebar container that should be used
                    position: 'left',     // left or right
                }).addTo(map);
                
                map.setView([50.666667, 17.933333], 4);

                map.spin(true);
                
                circle_group = new L.featureGroup();
                circle_group.addTo(map);
            
                frontline_group = new L.featureGroup();
                frontline_group.addTo(map);
                frontline_label_group = new L.featureGroup();
                frontline_label_group.addTo(frontline_group);
                optional_layers["Hauptkampflinie"] = frontline_group;

                var dhg_group = new L.featureGroup();
                createDHG(dhg_group);
                optional_layers["Deutsches Heeres Gitter"] = dhg_group;
                
                var legend = L.control({position: 'topright'});
                legend.onAdd = function(map) {
                    var div = L.DomUtil.create('div', 'info legend');
                    var labels = [];
                    
                    /* years */
                    labels.push('<strong>Years</strong>');
                    for (var i = 0; i < year_colors.length; i++) {
                        labels.push('<i style="background:' + year_colors[i] + '"></i> ' + (base_year + i));
                    }
                    
                    labels.push('<br>');
                    
                    /* dashes */
                    var transits = [["k", "Kämpfend"], ["v", "Verletzt"], ["f", "Fliehend"], ["u", "Urlaub"], ["t", "Transit"]];
                    labels.push('<strong>Transits</strong>');
                    for (var i = 0; i < transits.length; i++) {
                        var q = '<svg height="12" width="43"> <g fill="none" stroke="black" stroke-width="4"> <path stroke-dasharray="'
                                + get_dash(transits[i][0]) + '" d="M0 7 L35 7"></path></g> </svg>' + transits[i][1];
                        labels.push(q);
                    }
                    
                    div.innerHTML = labels.join('<br>');
                    return div;
                };
                legend.addTo(map);

                var start_date = new Date(window.localStorage.getItem("start-date") || "1939-01-01");
                var end_date = new Date(window.localStorage.getItem("end-date") || "1950-01-01");
                
                var timeselector = L.control({position: 'topleft'});
                timeselector.onAdd = function(map) {        
                    return document.getElementById("date-element");
                };
                timeselector.addTo(map);
                
                picker = new Lightpick({
                    field: document.getElementById('pick1'),
                    secondField: document.getElementById('pick2'),
                    singleDate: false,
                    repick: true,
                    startDate: start_date,
                    endDate: end_date,
                    onSelect: function(start, end){
                        plot(picker.getStartDate().toDate(), picker.getEndDate().toDate());
                        window.localStorage.setItem("start-date", picker.getStartDate().toDate().toISOString());
                        window.localStorage.setItem("end-date", picker.getEndDate().toDate().toISOString());
                    }
                });
                
                var osm2 = new L.TileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {minZoom: 0, maxZoom: 13, attribution: "" });
                var miniMap = new L.Control.MiniMap(osm2, {
                    centerFixed: [50.666667, 17.933333],
                    zoomLevelFixed: 2,
                    width: 250,
                    autoToggleDisplay: true,
                }).addTo(map);
                
                map.on('zoomend', toggleLabelsZoom);
                toggleLabelsZoom();

                person_data = load_person_data();
                frontline_data = load_frontline_data();
                location_data = load_location_data();

                Promise.all([person_data, frontline_data]).then((qqq) => {
                    selectPersons(Object.keys(person_data), start_date, end_date);

                    var global_bbox = null;
                    map.eachLayer(function (layers) {
                        if (!(typeof layers.eachLayer === 'function'))
                            return;

                        layers.eachLayer(function (layer) {
                            if(layer.getBounds == null)
                                return;
                            var b = layer.getBounds();
                            if(global_bbox == null)
                                global_bbox = b;
                            else global_bbox = global_bbox.extend(b);
                        });
                    });

                    map.fitBounds(global_bbox);

                    //do it in here so that the layer icon is above the persons
                    var saved_historic_map_url = window.localStorage.getItem(historic_map_key);
                    if(saved_historic_map_url != null) {
                        initializeHistoricMap(saved_historic_map_url);
                    }

                    map.spin(false);

                    L.control.layers(base_layers, optional_layers, {position: 'bottomleft', collapsed:false}).addTo(map);

                    L.control.ruler({position: 'bottomleft'}).addTo(map);
                    map.doubleClickZoom.disable();
                });

                var target = document.getElementById('search-element-spinner');
                var opts = {
                    lines: 12, // The number of lines to draw
                    length: 7, // The length of each line
                    width: 4, // The line thickness
                    radius: 10, // The radius of the inner circle
                    color: '#000', // #rgb or #rrggbb
                    speed: 1, // Rounds per second
                    trail: 60, // Afterglow percentage
                    shadow: false, // Whether to render a shadow
                    hwaccel: false, // Whether to use hardware acceleration
                    top: '50%', // Top position relative to parent
                    left: '50%', // Left position relative to parent
                    shadow: '0 0 1px transparent', // Box-shadow for the lines
                    position: 'absolute' // Element positioning
                };
                var spinner = new Spinner(opts).spin(target);
                location_data.then((q) => {
                    location_data = q;
                    spinner.stop();
                    document.getElementById("search-element").innerHTML = "";
                    document.getElementById("search-element").appendChild(document.getElementById("search-content"));
                });
            }

            function startSelectArea() {
                if(rect != null)
                    map.removeLayer(rect);
                rect = map.editTools.startRectangle();
                shades = new L.LeafletShades();
                shades.addTo(map);
            }

            function searchLocations() {
                var bbox = null;
                if(rect != null) {
                    bbox = rect.getBounds();
                }
                var text = document.getElementById("loc-name").value;
                var max_distance = document.getElementById("max-distance").value;
                var search_res = search_locations(location_data, bbox, text, max_distance);
                document.getElementById('search-results').innerHTML = 'Search Results:';
                for (var i = 0; i < search_res.length; i++) {
                    var location_name = search_res[i].name;
                    var location_box = search_res[i].box;
                    var htmlObject = document.createElement('div');
                    htmlObject.innerHTML = '<li onclick="jumpTo(this)">' + location_name + '</li>';
                    htmlObject.box = location_box;
                    document.getElementById('search-results').appendChild(htmlObject);
                }
            }

            function jumpTo(e) {
                var location_box = e.parentNode.box;
                location_box = L.latLngBounds(L.latLng(location_box[0]), L.latLng(location_box[1]));
                map.setView(location_box.getCenter(), 13)
            }

            function loadHistoricMaps() {
                var url = document.getElementById("historic-map-url-input").value;
                window.localStorage.setItem(historic_map_key, url);
                window.location.reload(false); 
            }

            function hideSelectedArea() {
                map.removeLayer(shades);
                map.removeLayer(rect);
                rect = null;
                document.getElementById('search-results').innerHTML = "";
            }
            
            function showCoordinates(e) {
                alert(e.latlng);
            }
            
            function addCircle(e) {
                var distance_km = prompt("Radius in km", 1.0);
                if (distance_km != null) {
                    var centerMarker = L.circle(e.latlng, distance_km * 1).addTo(circle_group);
                    var circle = L.circle(e.latlng, distance_km * 1000, {
                        contextmenu: true,
                        contextmenuItems: [{
                            text: distance_km + ' km',
                            index: 0
                        },
                        {
                            text: 'Change Radius',
                            callback: e => changeRadius(e, circle),
                            index: 1
                        },
                        {
                            text: 'Remove Circle',
                            callback: e => removeCircle(e, circle, centerMarker),
                            index: 2
                        },
                        {
                            separator: true,
                            index: 3
                        }]
                    }).addTo(circle_group);
                }
            }
            
            function removeCircles(e) {
                circle_group.clearLayers();
            }
            
            function removeCircle(e, circle, centerMarker) {
                circle_group.removeLayer(circle);
                circle_group.removeLayer(centerMarker);
                
            }
            
            function changeRadius(e, circle) {
                var distance_km = prompt("Radius in km", circle.getRadius() / 1000);
                if (distance_km != null) {
                    circle.setRadius(distance_km * 1000);
                }
            }
            
            function toggleLabelsZoom() {
                if (map.getZoom() < 4){
                    frontline_group.removeLayer(frontline_label_group);
                }
                else frontline_group.addLayer(frontline_label_group);
            }
            
            function btn_link(btn) {
                btn.children[0].className = btn.children[0].className == "fa fa-unlink" ? "fa fa-link" : "fa fa-unlink";
            }
            
            function btn_change_date(event, idx_date, delta, ty) {
                if (event.ctrlKey)
                    ty = ty == "days" ? "weeks" : "years";
            
                var start = picker.getStartDate().clone();
                var end = picker.getEndDate().clone();
                var linked = document.getElementById("btn_link").children[0].className == "fa fa-link";
            
                if(linked || idx_date == 0)
                    start.add(delta, ty);
            
                if(linked || idx_date == 1)
                    end.add(delta, ty);
            
                picker.setDateRange(start, end);
            }
            
            function btn_right() {
                var start = picker.getStartDate().clone();
                picker.setDateRange(start, start);
            }
            
            function btn_left() {
                var end = picker.getEndDate().clone();
                picker.setDateRange(end, end);
            }
        </script>
    </body>
</html>